#+title: Overview Code

#+property: header-args :mkdirp yes :results value drawer

#+name: attr_fit_width
#+begin_src bash :var data="" :var org_percent=50 :var latex_percent=80 :results output :exports none
  echo "#+attr_org: :width $org_percent%"
  echo "#+attr_latex: :width $(bc <<< "scale=2; $latex_percent/100")\linewidth"
  echo "$data"
#+end_src

#+RESULTS: attr_fit_width
:results:
#+attr_org: :width 50%
#+attr_latex: :width .80\linewidth

:end:

* Experiment No Automation

#+begin_src plantuml :file images/experiment_no_automation.png
  !include style.puml
  !include microscopy.puml

  !include <material/person_box>
  !include <material/document>

  component "user\n<$ma_person_box>" as user
  spmcon <--r-- user: low freq. \ncommands

  component "experiment\n<$ma_document>" as exp
  user <.. exp: experimental \nsteps
  #+end_src

  #+RESULTS:
  :results:
  [[file:images/experiment_no_automation.png]]
  :end:
* SPM-Specific Automation

#+begin_src plantuml :file images/experiment_with_script.png
  !include style.puml
  !include microscopy.puml

  !include <material/script>

  component "experiment script\n<$ma_script>" as exp_script
  spmcon <--r-- exp_script: low freq. \ncommands
  #+end_src

  #+RESULTS:
  :results:
  [[file:images/experiment_with_script.png]]
  :end:

* afspm High-Level Diagram

#+begin_src plantuml :file images/afspm_hl_diagram.png
  !include style.puml
  !include microscopy.puml

  !include <material/network>
  !include <material/tune>
  !include <material/chart_areaspline>
  !include <material/script>

  package "afspm abstraction" <<groupinternal>> {
    component "microscope\ntranslator\n<$ma_network>" <<interface>> <<required>> as devcon
    component "microscope\nscheduler\n<$ma_tune>" <<internal>> <<required>> as afspmcon

    component "experiment\n<$ma_script>" <<internal>> as exp
    component "visualizer\n<$ma_chart_areaspline>" <<internal>> as viz

    devcon <--> afspmcon

    afspmcon <--> exp
    afspmcon <--> viz
  }

  spmcon <-> devcon: low freq. \ncommands
  #+end_src

  #+RESULTS:
  :results:
  [[file:images/afspm_hl_diagram.png]]
  :end:
* afspm High-Level Diagram Example

#+begin_src plantuml :file images/afspm_hl_example.png
  !include style.puml
  !include microscopy.puml

  !include <material/network>
  !include <material/tune>
  !include <material/chart_areaspline>
  !include <material/script>
  !include <material/alert_box>
  !include <material/wrench>

  package "afspm abstraction" <<groupinternal>> as afspm {
    component "microscope\ntranslator\n<$ma_network>" <<interface>> <<required>> as devcon
    component "microscope\nscheduler\n<$ma_tune>" <<internal>> <<required>> as afspmcon

    component "experiment\n<$ma_script>" <<internal>> <<optional>> as exp
    component "tip detector\n<$ma_alert_box>" <<internal>> <<optional>> as tip_detector
    component "tip corrector\n<$ma_wrench>" <<internal>> <<optional>> as tip_corrector

    devcon <--> afspmcon

    afspmcon -l-> exp: scans,\nstate
    exp -r-> afspmcon: scan\nparameters

    afspmcon --> tip_detector: scans
    tip_detector .u.> afspmcon: log\nproblem
    afspmcon -r-> tip_corrector: current\nproblems
    tip_corrector .l.> afspmcon: fixing\nactions
  }

  spmcon <-r-> devcon: low freq. \ncommands

  #+end_src

  #+RESULTS:
  :results:
  [[file:images/afspm_hl_example.png]]
  :end:

* afspm Network framework

#+begin_src plantuml :file images/network_framework.png
  !include style.puml

  component "Component A" <<internal>> as comp_a {
    component "PUB\n//(zmq socket)//" <<socket>> as socket_a
    component proto_a <<message>> <<left>> [
    message
    {
        int num;
        str name;
    }
    ]

    component "list[bytes]" as bytes_a
    proto_a .u.> bytes_a: serialize
    bytes_a .u.> socket_a
  }

  component "Component B" <<internal>> as comp_b {
    component "SUB\n//(zmq socket)//" <<socket>> as socket_b
    component proto_b <<message>> <<left>> [
    message
    {
        int num;
        str name;
    }
    ]

    component "list[bytes]" as bytes_b
    socket_b .d.> bytes_b
    bytes_b .d.> proto_b: "deserialize\t"
  }

  interface node <<node>> as "//zmq node//\n(e.g., tcp://localhost:9000)"
  ' silly hack to add spacing'
  socket_a --r--> node: "//published to node//"
  node --r--> socket_b: "//sent to subscribers//"
  #+end_src

  #+RESULTS:
  :results:
  [[file:images/network_framework.png]]
  :end:
* afspm without afspm controller

#+header: :post attr_fit_width(data=*this*, org_percent=75, latex_percent=90)
#+begin_src plantuml :file images/afspm_without_afspmcon.png
  !include style.puml
  !include microscopy.puml
  !include <material/network>
  !include <material/script>

  package "afspm abstraction" <<groupinternal>> {
    component "microscope\ntranslator\n<$ma_network>" <<interface>> <<required>> as devcon {
      component "PUB" <<socket>> as dc_pub
      component REP <<socket>> as dc_rep
    }

    component "experiment\n<$ma_script>" <<internal>> as exp {
      component SUB <<socket>> as exp_sub
      component REQ <<socket>> as exp_req
    }

    dc_pub -d-> exp_sub: data, \nstatus
    exp_req -u-> dc_rep: control\nrequests
  }

  spmcon <-> devcon: "low freq.\ncommands"
  #+end_src

  #+RESULTS:
  :results:
  #+attr_org: :width 75%
  #+attr_latex: :width .90\linewidth
  [[file:images/afspm_without_afspmcon.png]]
  :end:

* afspm control

#+header: :post attr_fit_width(data=*this*, org_percent=80, latex_percent=90)
#+begin_src plantuml :file images/afspm_control.png
  !include style.puml
  !include microscopy.puml
  left to right direction

  !include <material/network>
  !include <material/tune>
  !include <material/chart_areaspline>
  !include <material/script>

  package "afspm abstraction" <<groupinternal>> {
    component "microscope\ntranslator\n<$ma_network>" <<interface>> <<required>> as devcon {
      component PUB <<socket>> as dc_pub
      component REP <<socket>> as dc_rep
    }


    component "afspm director\n<$ma_tune>" <<internal>> <<required>> as afspm_con {
      component SUB <<socket>> as afspm_sub
      component XPUB <<socket>> as afspm_pub
      component "//cache//" as afspm_cache
      afspm_sub .. afspm_cache
      afspm_cache .. afspm_pub

      component REQ <<socket>> as afspm_req
      component ROU <<socket>> as afspm_rou
      component "//control//" as afspm_ctrl
      afspm_req .. afspm_ctrl
      afspm_ctrl .. afspm_rou
    }

    dc_pub -d-> afspm_sub: data, \nstatus
    dc_rep <-d- afspm_req: control\nrequests


    component "experiment\n<$ma_script>" <<internal>> as exp {
      component SUB <<socket>> as exp_sub
      component REQ <<socket>> as exp_req
    }

    afspm_pub --> exp_sub: scan_state
    afspm_rou <-- exp_req: scan_params\nstart_scan\nstop_scan

    component "visualizer\n<$ma_chart_areaspline>" <<internal>> as viz {
      component SUB <<socket>> as viz_sub
      component REQ <<socket>> as viz_req
    }

    afspm_pub --> viz_sub: scans
    afspm_rou <-r- viz_req: tip_state
  }

  spmcon <--> devcon: low freq. \ncommands

  'note as note_cache
  ''  Cache stores data/state passed to subscribers.
  ''  When a new subsciption occurs, we send from the cache.
  ''  If a node crashes, on reconnection it gets this prior history.
  'end note
  'note_cache -[hidden]- afspm

  'note as note_control
  ''  Control handles routing data from 1 or more REQs to the Device Controller.
  ''  It also allows turning OFF/pausing (for manual control).
  ''  It also can receive "Problems" (e.g. bad tip state).
  ''  Upon a problem, automated control pauses until a node states it is fixed.
  'end note
  'note_control -[hidden]- afspm

  #+end_src

  #+RESULTS:
  :results:
  #+attr_org: :width 80%
  #+attr_latex: :width .90\linewidth
  [[file:images/afspm_control.png]]
  :end:
* Translator Role
** Without afspm
#+begin_src plantuml :file images/code_reuse_without_afspm.png
  !include style.puml
  !include <material/microscope>
  !include <material/monitor>
  !include <material/script>

  component "**GXSM**\n<$ma_microscope> + <$ma_monitor>" <<example1>> as gxsm
  component "**Asylum Research**\n<$ma_microscope> + <$ma_monitor>" <<example2>> as asylum
  component "**Scienta Omicron**\n<$ma_microscope> + <$ma_monitor>" <<example3>> as omicron

  component "GXSM Script\n<$ma_script>" <<example1>> as gxsm_script
  component "Asylum Script\n<$ma_script>" <<example2>> as asylum_script
  component "Omicron Script\n<$ma_script>" <<example3>> as omicron_script

  gxsm <-d- gxsm_script: Custom \nPython \nAPI
  asylum<-d- asylum_script: Custom \nIGOR \nAPI
  omicron <-d- omicron_script: Custom \nPython \nAPI

  gxsm_script .r.> asylum_script: conversion / \nrewrite
  asylum_script .r.> omicron_script: conversion / \nrewrite
#+end_src

#+RESULTS:
:results:
[[file:images/code_reuse_without_afspm.png]]
:end:

** With afspm

#+begin_src plantuml :file images/code_reuse_with_afspm.png
  !include style.puml
  !include <material/microscope>
  !include <material/monitor>
  !include <material/script>
  !include <material/network>

  component "**GXSM**\n<$ma_microscope> + <$ma_monitor>" <<example1>> as gxsm
  component "**Asylum Research**\n<$ma_microscope> + <$ma_monitor>" <<example2>> as asylum
  component "**Scienta Omicron**\n<$ma_microscope> + <$ma_monitor>" <<example3>> as omicron

  'Enforce order'
  gxsm -[hidden]r- asylum
  asylum -[hidden]r- omicron

  package "afspm abstraction" <<groupinternal>> {
    component "microscope \ntranslators" <<internal>> as translators {
      component "GXSM \ntranslator\n<$ma_network>" <<example1>> <<required>> as gxsm_tr
      component "Asylum \ntranslator\n<$ma_network>" <<example2>> <<required>> as asylum_tr
      component "Omicron \ntranslator\n<$ma_network>" <<example3>> <<required>> as omicron_tr
    }

    component "afspm script\n<$ma_script>" <<internal>> as exp
  }

  gxsm_tr -u-> gxsm: Custom \nPython \nAPI
  asylum_tr -u-> asylum: Custom \nIGOR \nAPI
  omicron_tr -u-> omicron: Custom \nPython \nAPI

  exp .u.> gxsm_tr: "   afspm"
  exp .u.> asylum_tr: "   calls"
  exp .u.> omicron_tr

#+end_src

#+RESULTS:
:results:
[[file:images/code_reuse_with_afspm.png]]
:end:
