# ================================================
#  config.toml for continuously scanning a region.
# ================================================

# ----- General variables ----- #
# --- URLs --- #
pub_url = "tcp://127.0.0.1:9000"
psc_url = "tcp://127.0.0.1:9001"
server_url = "tcp://127.0.0.1:6666"
router_url = "tcp://127.0.0.1:6667"
xop_url = 'tcp://127.0.0.1:5555'  # To be used on zmq-xop server startup in Igor
rescan_url = "tcp://127.0.0.1:9005"

request_timeout_ms = 5000  # Need a very long timeout for asylum...

# --- Experiment Scan Aspects --- #
# - Physical Stuff - #
our_phys_units = 'um'
full_scan_origin = [0, 0]
full_scan_size = [5, 5]

# - Data Stuff - #
data_units = 'pixels'
full_scan_res = [128, 128]

channel_id = 'HeightRetrace'


# ----- Cache Logic ----- #
[pbc_scan_logic]
class = 'afspm.io.pubsub.logic.pbc_logic.PBCScanLogic'
default_scan_history = 5

[cache_kwargs]
cache_logic = 'pbc_scan_logic'

# ----- PubSub ----- #
[pub]
class = 'afspm.io.pubsub.publisher.Publisher'
url = 'pub_url'

[psc]
class = 'afspm.io.pubsub.cache.PubSubCache'
url = 'psc_url'
sub_url = 'pub_url'
update_cache_kwargs = 'cache_kwargs'

[sub]
class = 'afspm.io.pubsub.subscriber.Subscriber'
sub_url = 'psc_url'

[rescan_pub]
class = 'afspm.io.pubsub.publisher.Publisher'
url = 'rescan_url'

[rescan_sub]
class = 'afspm.io.pubsub.subscriber.Subscriber'
sub_url = 'rescan_url'

# ----- Control Logic ----- #
[server]
class = 'afspm.io.control.server.ControlServer'
url = 'server_url'

[router]
class = 'afspm.io.control.router.ControlRouter'
server_url = 'server_url'
router_url = 'router_url'
request_timeout_ms = 'request_timeout_ms'

[client]
class = 'afspm.io.control.client.ControlClient'
url = 'router_url'
request_timeout_ms = 'request_timeout_ms'

[ui_client]
class = 'afspm.io.control.client.AdminControlClient'
url = 'router_url'

# ----- Additional ----- #

[xopclient]
class = 'afspm.components.microscope.translators.asylum.client.XopClient'
url = 'xop_url'
timeout_s = 20  # 4x the request timeout

# ----- Components ----- #
[exp_data]  # NOTE: this could have been hardcoded, really.
class = 'experiment.ExperimentData'
scan_origin = 'full_scan_origin'
scan_size = 'full_scan_size'
length_units = 'our_phys_units'
scan_res = 'full_scan_res'

[experiment]
class = 'afspm.components.scan.handler.ScanningComponent'
component = true

subscriber = 'sub'
control_client = 'client'

rerun_wait_s = 60  # 1 min
get_next_params = 'experiment.get_next_scan_params'
next_params_kwargs = {'exp_data'= 'exp_data'}

[ui]
component = true
class = 'afspm.components.control_ui.AfspmControlUI'

subscriber = 'sub'
control_client = 'ui_client'

[visualizer]
#component = true
class = 'afspm.components.visualizer.Visualizer'
scan_id = 'Scan2d'
subscriber = 'sub'
control_client = 'ui_client'  # TODO: Do we need this?

[scheduler]
component = true
class = 'afspm.components.drift.scheduler.CSCorrectedScheduler'
pubsubcache = 'psc'
router = 'router'
publisher = 'rescan_pub'  # Publish rescan requests
channel_id = 'channel_id'

[rescanner]
component = true
class = 'afspm.components.drift.rescanner.DriftRescanner'
rerun_wait_s = 60  # 1 min
subscriber = 'rescan_sub'  # Listen to rescan requests
control_client = 'client'

[translator]
component = true
class = 'afspm.components.microscope.translators.asylum.translator.AsylumTranslator'

xop_client = 'xopclient'

publisher = 'pub'
control_server = 'server'
subscriber = 'sub'  # To close itself when we tell it to.

[metadata]
component = true
class = 'afspm.components.scan.metadata.ScanMetadataWriter'
subscriber = 'sub'
